#!/usr/bin/env ruby
# frozen_string_literal: true

require "curses"
require "esphome"
require "time"

ANSI_COLOR_MAP = {
  30 => Curses::COLOR_BLACK,
  31 => Curses::COLOR_RED,
  32 => Curses::COLOR_GREEN,
  33 => Curses::COLOR_YELLOW,
  34 => Curses::COLOR_BLUE,
  35 => Curses::COLOR_MAGENTA,
  36 => Curses::COLOR_CYAN,
  37 => Curses::COLOR_WHITE
}.freeze

# Regex to match ANSI color codes (like \e[31m)
ANSI_ESCAPE_REGEX = /\e\[(\d+(?:;\d+)*)m/

def parse_sgr_codes(codes)
  color = nil
  attr = Curses::A_NORMAL

  codes.each do |code|
    code = code.to_i
    if ANSI_COLOR_MAP.key?(code)
      color = ANSI_COLOR_MAP[code]
    elsif code == 1
      attr |= Curses::A_BOLD
    elsif code == 4
      attr |= Curses::A_UNDERLINE
    elsif code.zero?
      attr = Curses::A_NORMAL
      color = nil
    end
  end

  [color, attr]
end

def parse_ansi_and_render(line)
  @win.clrtoeol
  current_color = nil
  current_attr = Curses::A_NORMAL

  line.split(ANSI_ESCAPE_REGEX).each_with_index do |part, i|
    if i.odd?
      codes = part.split(";").map(&:to_i)
      current_color, current_attr = parse_sgr_codes(codes)
    elsif current_color
      pair_id = current_color + 1
      @win.attron(Curses.color_pair(pair_id) | current_attr) do
        @win.addstr(part)
      end
    else
      @win.attron(current_attr) do
        @win.addstr(part)
      end
    end
  end
end

@device = ESPHome::Device.new(ARGV[0], ARGV[1], logger: Logger.new(IO::NULL))

def print_entity(entity, clear_line: true)
  return unless @entities.key?(entity.key) # has an unsupported entity

  @win.setpos(@entities[entity.key] + 3, 0)
  @win.clrtoeol if clear_line
  name = "#{entity.class.name.split("::").last} - #{entity.name}"
  @win.addstr("#{name.ljust(40)}: [#{Time.now.strftime("%H:%M:%S")}] #{entity.formatted_state}")
end

def visible_lines
  @win.maxy - @entities.size - 5
end

def render_log(visible_lines = nil)
  visible_lines ||= self.visible_lines

  @log_lines.each_with_index do |log_line, idx|
    break if idx >= visible_lines

    @win.setpos(@entities.size + 4 + idx, 0)

    parse_ansi_and_render(log_line)
  end
end

def render_all
  @win.clear
  @win.setpos(0, 0)
  @win.addstr("ESPHome")
  @win.setpos(1, 0)
  @win.addstr("#{@device.friendly_name.ljust(45)} (#{@device.esphome_version} - #{@device.compilation_time})")
  @win.setpos(2, 0)
  @win.addstr("=" * 80)

  @device.entities.each_value do |entity|
    next unless entity.is_a?(ESPHome::Entity::HasState)

    print_entity(entity, clear_line: false)
  end

  render_log

  @win.refresh
end

Signal.trap("SIGWINCH") do
  render_all
end

@log_lines = []

@device.on_message do |entity_or_log_line|
  if entity_or_log_line.is_a?(String)
    visible_lines = self.visible_lines
    @log_lines << "[#{Time.now.strftime("%H:%M:%S")}]#{entity_or_log_line}"
    @log_lines.shift if @log_lines.size > [20, visible_lines].max

    render_log
  else
    print_entity(entity_or_log_line)
  end
  @win.refresh
end

@device.connect

@entities = {}
@device.entities.values.grep(ESPHome::Entity::HasState).sort_by(&:name).each_with_index do |entity, idx|
  @entities[entity.key] = idx
end

Curses.init_screen
begin
  Curses.noecho
  Curses.start_color
  Curses.use_default_colors
  @win = Curses.stdscr
  ANSI_COLOR_MAP.each_value do |color|
    Curses.init_pair(color + 1, color, -1)
  end

  render_all

  @device.stream_states
  @device.stream_log(dump_config: true)
  @device.loop
rescue Interrupt
  # exitting
ensure
  Curses.close_screen
end
